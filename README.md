## Reflection
###### 1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
Perbedaan utama antara metode RPC unary, server streaming, dan bi-directional streaming terletak pada cara klien dan server bertukar pesan. RPC unary melibatkan satu permintaan dari klien ke server dan satu respons kembali, cocok untuk interaksi sederhana seperti autentikasi atau pengiriman formulir. RPC server streaming melibatkan satu permintaan dari klien tetapi menerima serangkaian respons dari server, berguna saat server perlu mengirimkan data besar seperti mengunduh file besar. Sementara itu, RPC bi-directional streaming memungkinkan klien dan server saling mengirimkan aliran pesan secara independen, cocok untuk aplikasi real-time seperti obrolan atau permainan online.

###### 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
Dalam mengimplementasikan layanan gRPC di Rust, pertimbangan keamanan yang penting termasuk penggunaan autentikasi yang kuat seperti TLS untuk mengamankan komunikasi antara klien dan server, implementasi mekanisme otorisasi yang memastikan hanya pengguna yang diotorisasi yang memiliki akses ke sumber daya tertentu, dan enkripsi data baik selama transmisi maupun penyimpanan untuk melindungi informasi yang sensitif dari akses yang tidak sah. Dengan langkah-langkah ini, integritas dan kerahasiaan data dalam layanan gRPC dapat dijaga dengan baik.

###### 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
Streaming dua arah dalam gRPC Rust menghadapi tantangan dalam manajemen konkurensi, penanganan kesalahan, dan penataan pesan. Memastikan komunikasi yang lancar antara klien dan server, menangani kesalahan dengan efektif, dan mengelola aliran pesan yang benar-benar penting. Tantangan lainnya termasuk penanganan tekanan balik, alokasi sumber daya, dan memastikan keamanan serta skalabilitas. Mengatasi tantangan-tantangan ini penting untuk menjaga kinerja dan kehandalan, terutama dalam aplikasi obrolan di mana interaksi real-time sangat diperlukan.

###### 4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
Keuntungan menggunakan tokio_stream::wrappers::ReceiverStream adalah kemudahan integrasi dengan tokio dan tokio-based libraries, karena ReceiverStream dapat mengubah tokio::sync::mpsc::Receiver menjadi stream async yang dapat digunakan dalam gRPC Rust dengan mudah. Namun, kerugiannya adalah bahwa ReceiverStream tidak menyediakan dukungan built-in untuk mengelola kesalahan atau buffering data secara otomatis, sehingga kita perlu menangani ini secara manual. Ini bisa menjadi kompleksitas tambahan terutama dalam skenario di mana penanganan kesalahan dan manajemen aliran data yang baik sangat penting, seperti dalam streaming gRPC.

###### 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
Untuk meningkatkan penggunaan ulang dan modularitas, serta mempromosikan kemudahan pemeliharaan dan perluasan kode dari waktu ke waktu, kode gRPC Rust dapat diorganisir dengan memisahkan layanan ke dalam modul terpisah berdasarkan fungsionalitas terkait, dan memisahkan definisi pesan ke dalam file terpisah. Dengan pendekatan ini, setiap layanan menjadi mandiri dan mudah diuji, sementara definisi pesan dapat digunakan kembali di berbagai layanan, memungkinkan pengembangan yang lebih efisien dan fleksibel.

###### 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
Untuk menangani logika pemrosesan pembayaran yang lebih kompleks dalam implementasi MyPaymentService, langkah-langkah tambahan melibatkan melakukan validasi yang menyeluruh, mengintegrasikan layanan dengan gateway pembayaran eksternal, dan mencatat data transaksi untuk tujuan audit. Manajemen konkurensi, kepatuhan keamanan, dan skalabilitas juga merupakan faktor penting yang perlu dipertimbangkan. Selain itu, pengujian menyeluruh dan desain untuk ketersediaan tinggi dan skalabilitas sangat diperlukan untuk memastikan kehandalan dan kinerja layanan.

###### 7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
Adopsi gRPC berdampak pada arsitektur dan desain sistem terdistribusi dengan menyediakan komunikasi yang efisien, kontrak layanan yang tidak bergantung pada bahasa pemrograman, dan kemampuan streaming dua arah. Ini meningkatkan interoperabilitas dengan fitur seperti transcoding JSON dan dukungan HTTP/1.x, sementara juga mempromosikan sistem yang skalabel, fault-tolerant, dan kompatibel dengan arsitektur mikroservis modern serta dapat berintegrasi dengan infrastruktur legacy.

###### 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
HTTP/2, sebagai protokol yang mendasari gRPC, memiliki keuntungan dalam hal multiplexing, kompresi header, dan server push, yang meningkatkan efisiensi jika dibandingkan dengan HTTP/1.1 atau HTTP/1.1 dengan WebSocket untuk API REST. Namun, penggunaan HTTP/2 juga menambah kompleksitas dan mungkin menghadapi masalah kompatibilitas dengan beberapa sistem. WebSocket lebih cocok untuk komunikasi real-time. Pilihan antara HTTP/2 dan WebSocket bergantung pada kebutuhan kinerja, kendala kompatibilitas, dan kasus penggunaan yang spesifik.

###### 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
Model request-response dari API REST berbeda dengan kemampuan streaming dua arah dari gRPC dalam hal komunikasi real-time dan responsif. API REST menggunakan model request-response, sedangkan gRPC menyediakan streaming dua arah untuk komunikasi real-time. API REST lebih cocok untuk interaksi stateless, sementara gRPC lebih unggul dalam skenario yang memerlukan pembaruan terus-menerus, seperti aplikasi obrolan. Dengan menggunakan streaming dua arah, gRPC memungkinkan pertukaran data instan yang lebih responsif daripada API REST.

###### 10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
Implikasi dari pendekatan berbasis skema gRPC menggunakan Protocol Buffers, dibandingkan dengan sifat yang lebih fleksibel tanpa skema dari JSON dalam payload API REST adalah Bahia Pendekatan berbasis skema gRPC menjamin tipe data yang kuat dan serialisasi yang efisien, yang dapat meningkatkan performa dan interoperabilitas. Di sisi lain, JSON dalam API REST menawarkan fleksibilitas tetapi mungkin menyebabkan inkonsistensi dan tantangan dalam validasi. Pilihan antara keduanya tergantung pada kebutuhan performa, interoperabilitas, dan fleksibilitas.

